<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Departure Board Layout</title>
    <style>
        /* Load the custom font */
        @font-face {
            font-family: 'BlackBox';
            src: url('https://raw.githubusercontent.com/MichaelH12345/Departures1/main/BlackBox_Font.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        a {
    color: white;  /* Set the link color to white */
    text-decoration: none;  /* Remove underline */
    pointer-events: none;  /* Disable clicking */
    cursor: default;  /* Change the cursor to default (non-clickable) */
}

        /* Hide scrollbars for the entire page */
        html, body {
            overflow: hidden; /* Hide scrollbars */
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: black; /* Set background to black */
            display: flex;
            font-family: 'BlackBox', sans-serif; /* Apply the custom font */
            flex-direction: column; /* Ensure the footer is pushed to the bottom */
        }

        /* Container to hold the 3 sections */
        .container {
            display: flex;
            width: 100%;
            height: calc(100% - 100px); /* Adjust height to accommodate footer */
        }

        /* Each section takes up one-third of the container width */
        .section {
            flex: 1;
            height: 100%;
            position: relative;
            padding: 25px; /* Padding for text positioning */
            color: white; /* Default text color */
            box-sizing: border-box;
        }

        /* Add a vertical line on the right side of the first and second sections */
        .section:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 2px; /* Thickness of the line */
            height: 100%;
            background-color: grey; /* Grey color for the line */
        }

        /* Styling for the platform text */
        .platform {
            color: yellow;
            font-size: 50px;
        }

        /* Styling for the time text */
        .time-container {
            display: flex;
            align-items: center;
            margin-top: 25px;
            position: relative;
        }

        .time {
            font-size: 70px;
        }

        /* Styling for the status box */
        .status-box {
            font-size: 40px;
            font-weight: bold;
            padding: 0 20px;
            border-radius: 10px;
            line-height: 70px; 
            height: 70px;
            width: 250px; /* Fixed width */
            text-align: center;
            margin-left: 20px;
            position: absolute;
            right: 0px; /* Position 25px from the right of the section */
            top: 0; /* Align with the time */
        }

        /* Styling for the destination text */
        .destination {
            font-size: 70px;
            white-space: pre-wrap; /* Preserve formatting */
            line-height: 1.2;
        }

        /* Container for the TOC and carriages info */
        .info {
            position: absolute;
            top: 375px; /* Position 200px from the top of the section */
            left: 25px; /* Align with the padding of the section */
            right: 25px; /* Maintain padding on the right side */
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 35px;
        }

        /* Yellow color for the carriages info */
        .carriages {
            color: yellow;
        }

        /* Styling for the TOC info */
        .toc {
            color: grey;
        }

        /* Styling for no data in carriages */
        .no-data {
            color: black;
        }

        /* Styling for the calling points text box */
        .calling-points {
            position: absolute;
            top: 425px; /* 100px from the top of the section */
            left: 25px; /* 25px from the left of the section */
            width: calc(100% - 50px); /* Full width minus padding */
            max-height: calc(100% - 150px); /* Ensure it doesn't overflow */
            overflow: hidden; /* Remove scroll bar */
            color: white;
            font-size: 45px;
            padding: 0; /* No padding */
        }

        /* Grey rectangle at the bottom of the page */
        .footer {
            background-color: grey;
            color: yellow;
            height: 150px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 90px; /* Adjusted font size */
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            font-weight: bold;
            text-align: center; /* Center-align text */
            position: absolute; /* Position it absolutely */
            width: 3840px; /* Set width of the footer */
            right: 0;
            bottom: 0; /* Align it to the bottom */
        }

/* Reason box styling */
.reason-box {
    position: absolute;
    width: calc(100% - 50px); /* Full width minus 25px padding on each side */
    height: 150px;
    background-color: grey;
    color: white;
    border-left: 5px solid red; /* Default red border for delay/cancellation reasons */
    padding: 25px;
    box-sizing: border-box;
    bottom: 75px;
    left: 25px; /* 25px from the left of the section */
    overflow: hidden; /* Ensure text doesn't overflow */
    display: flex;
    align-items: center; /* Center text vertically */
    justify-content: center; /* Center text horizontally */
    font-size: 40px; /* Adjust font size as needed */
}

/* Class for yellow border when displaying general information */
.reason-box.yellow-border {
    border-left: 5px solid yellow;
}



        /* Styling for the special notices text box */
        .special-notices {
            font-family: BlackBox, sans-serif;
            position: absolute;
            top: 135px; /* Position 50px from the top */
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            width: calc(100% - 50px); /* Full width minus padding */
            color: white;
            font-size: 47.5px;
            text-align: center;
        }



            .notices {
            font-family: BlackBox, sans-serif;
            position: absolute;
            top: 25px; /* Position 50px from the top */
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            width: calc(100% - 50px); /* Full width minus padding */
            color: yellow;
            font-size: 75px;
            text-align: center;
        }


        /* Add a horizontal grey line 300 pixels from the bottom of Box 3 */
.section[data-index="5"]::before {
    content: '';
    position: absolute;
    bottom: 250px; /* Position 300px from the bottom of the section */
    left: 0;
    width: 100%;
    height: 2px; /* Thickness of the line */
    background-color: grey; /* Grey color for the line */
}


        /* Ensure the iframe fits within the section */
        .section iframe {
            display: none; /* Hide the iframe */
        }

        /* Styling for the current time text box */
        .current-time {
            font-family: Arial, sans-serif;
            font-weight: bold;
            font-size: 150px;
            color: white;
            text-align: center;
            position: absolute;
            bottom: 67.5px;
            left: 0;
            width: 100%;
        }

    </style>
</head>
<body>

 <div class="container">
    <!-- Section 1 -->
    <div class="section" data-index="3">
        <div class="platform"></div>
        <div class="time-container">
            <div class="time"></div>
            <div class="status-box"></div>
        </div>
        <div class="destination"></div>
        <div class="info">
            <div class="toc"></div>
            <div class="carriages"></div>
        </div>
        <div class="calling-points"></div> <!-- New text box for calling points -->
        <div class="reason-box"></div> <!-- New text box for reason -->
    </div>
    <!-- Section 2 -->
    <div class="section" data-index="4">
        <div class="platform"></div>
        <div class="time-container">
            <div class="time"></div>
            <div class="status-box"></div>
        </div>
        <div class="destination"></div>
        <div class="info">
            <div class="toc"></div>
            <div class="carriages"></div>
        </div>
        <div class="calling-points"></div> <!-- New text box for calling points -->
        <div class="reason-box"></div> <!-- New text box for reason -->
    </div>
        <!-- Section 3 -->
        <div class="section" data-index="5">
            <div class="notices">Information</div>
            <div class="special-notices" id="special-notices"></div>
            <div class="current-time" id="current-time"></div>
        </div>
</div>


    <!-- Grey footer with station name -->
    <div class="footer" id="station-footer">
        <span id="station-name">N/A</span>
    </div>

<script>
    // Function to format time into BST hours and minutes
    function formatTime(timeString) {
        if (!timeString) return 'N/A';
        const date = new Date(timeString);
        const localDate = new Date(date.getTime() + date.getTimezoneOffset() * 60000 + 3600000); // Convert to local time and adjust for BST
        return `${localDate.getHours().toString().padStart(2, '0')}:${localDate.getMinutes().toString().padStart(2, '0')}`;
    }

    // Function to truncate text if it's longer than a given length
    function truncateText(text, length) {
        if (text.length > length) {
            return text.substring(0, length) + '...';
        }
        return text;
    }

    // Function to truncate calling point text to a maximum length of 14 characters
    function truncateCallingPoint(text) {
        if (text.length > 17) { // Check if the length exceeds 17 characters
            return text.substring(0, 14) + '...';
        }
        return text;
    }

    // Variable to store previous calling points and subsequent locations for comparison
    let previousCallingPoints = [];
    let previousSubsequentLocations = [];
    let previousDestinations = []; // Track previous destinations

    // Fetch and cache lateness codes
    let latenessCodes = {};
    async function fetchLatenessCodes() {
        try {
            const response = await fetch('https://raw.githubusercontent.com/davwheat/raildotmatrix.co.uk/main/src/api/LatenessCodes.json');
            latenessCodes = await response.json();
            console.log('Lateness Codes:', latenessCodes);
        } catch (error) {
            console.error('Error fetching lateness codes:', error);
        }
    }

    // Fetch and cache cancellation codes
    let cancellationCodes = {};
    async function fetchCancellationCodes() {
        try {
            const response = await fetch('https://raw.githubusercontent.com/davwheat/raildotmatrix.co.uk/main/src/api/CancellationCodes.json');
            cancellationCodes = await response.json();
            console.log('Cancellation Codes:', cancellationCodes);
        } catch (error) {
            console.error('Error fetching cancellation codes:', error);
        }
    }

    // Initialize function to fetch codes
    async function initialize() {
        await fetchLatenessCodes();
        await fetchCancellationCodes();
    }

    // Function to handle formation and toilet information
    function handleFormationAndToilets(service) {
        const coaches = service.formation && service.formation.coaches ? service.formation.coaches : [];
        const accessibleToilets = [];

        let hasFirstClass = false;
        let accessibleToiletsCount = 0;
        let onlyStandardClass = true;

        // Initialize length variables
        const formationLength = service.formation && service.formation.length ? service.formation.length : null;
        const serviceLength = service.length ? service.length : null;

        let displayLength = 0;

        if (formationLength !== null && formationLength > 0) {
            displayLength = Math.max(displayLength, formationLength);
        }

        if (serviceLength !== null && serviceLength > 0) {
            displayLength = Math.max(displayLength, serviceLength);
        }

        // Check for first class and accessible toilets
        if (coaches.length > 0) {
            coaches.forEach((coach) => {
                // Determine if the train has first class coaches
                if (coach.coachClass === 'First') {
                    hasFirstClass = true;
                    onlyStandardClass = false; // There's first class, so it's not only standard
                } else if (coach.coachClass === 'Standard') {
                    onlyStandardClass = onlyStandardClass && true; // Keep it true if all coaches are standard
                }

                // Check for Accessible toilets
                if (coach.toilet && coach.toilet.value === 'Accessible') {
                    accessibleToilets.push(coach.number);
                    accessibleToiletsCount++;
                }
            });
        }

        // Prepare formation info
        let formationInfo = '';
        let firstClassFront = null;
        let firstClassRear = null;
        let standardClassFront = null;
        let standardClassRear = null;
        let accessibleToiletsList = [];

        if (coaches.length > 0) {
            coaches.forEach((coach) => {
                if (coach.coachClass === 'First') {
                    if (firstClassFront === null) {
                        firstClassFront = coach.number;
                    } else {
                        firstClassRear = coach.number;
                    }
                } else if (coach.coachClass === 'Standard') {
                    if (standardClassFront === null) {
                        standardClassFront = coach.number;
                    }
                    standardClassRear = coach.number;
                }

                // Check for Accessible toilets
                if (coach.toilet && coach.toilet.value === 'Accessible') {
                    accessibleToiletsList.push(coach.number);
                }
            });

            if (firstClassFront !== null && firstClassRear !== null) {
                formationInfo += `First ${firstClassFront} - ${firstClassRear}`;
            } else if (onlyStandardClass) {
                formationInfo += '';
            }

            if (standardClassFront !== null && standardClassRear !== null) {
                formationInfo += (formationInfo ? '\n' : '') + `Standard ${standardClassFront} - ${standardClassRear}`;
            }

            if (accessibleToiletsList.length === 1) {
                formationInfo += (formationInfo ? '\n' : '') + `Accessible toilet in coach ${accessibleToiletsList[0]}.`;
            } else if (accessibleToiletsList.length > 1) {
                formationInfo += (formationInfo ? '\n' : '') + `Accessible toilet in coaches ${accessibleToiletsList.slice(0, -1).join(', ')} and ${accessibleToiletsList.slice(-1)}.`;
            } else {
                formationInfo += (formationInfo ? '\n' : '') + 'No accessible toilet onboard.';
            }
        }

        // Determine additional messages for West Midlands Railway
        let priorityInfo = '';
        if (service.operator === 'West Midlands Trains') {
            if (hasFirstClass) {
                priorityInfo += 'First class is available on the train.';
            }
            if (accessibleToiletsCount === 1) {
                priorityInfo += (priorityInfo ? '\n' : '') + 'Accessible toilet onboard.';
            } else if (accessibleToiletsCount > 1) {
                priorityInfo += (priorityInfo ? '\n' : '') + 'Accessible toilets onboard.';
            }
            if (onlyStandardClass) {
                priorityInfo += (priorityInfo ? '\n' : '') + '';
            }

            return priorityInfo.trim(); // Return priority info for West Midlands Railway
        }

        return formationInfo.trim(); // Return general formation information
    }

    // Function to handle reasons for delay and cancellation
    function handleReasons(service, section) {
        const reasonBox = section.querySelector('.reason-box');

        // Reset the reason box
        reasonBox.classList.remove('yellow-border'); // Remove any previous border class
        reasonBox.style.borderLeft = 'none'; // Reset border style
        reasonBox.style.display = 'none'; // Hide reason box initially

        if (service.isCancelled && service.cancelReason && service.cancelReason.value) {
            const cancelCode = service.cancelReason.value;
            const cancelReason = cancellationCodes[cancelCode] || 'Unknown cancellation reason';
            reasonBox.textContent = cancelReason.replace('This train has been cancelled because of', 'Service cancelled because of');
            reasonBox.style.borderLeft = '10px solid red'; // Red border for cancellation
            reasonBox.style.display = 'flex'; // Show the reason box
        } else if (service.delayReason && service.delayReason.value) {
            const delayCode = service.delayReason.value;
            const delayReason = latenessCodes[delayCode] || 'Unknown delay reason';
            reasonBox.textContent = delayReason.replace('This train has been delayed by', 'Train delayed by');
            reasonBox.style.borderLeft = '10px solid red'; // Red border for delay
            reasonBox.style.display = 'flex'; // Show the reason box
        } else {
            // Handle formation and toilet information
            const formationInfo = handleFormationAndToilets(service);

            if (formationInfo) {
                reasonBox.textContent = formationInfo; // Update reason box with formation info
                reasonBox.style.borderLeft = '10px solid yellow'; // Yellow border for general info
                reasonBox.style.display = 'flex'; // Show the reason box
            }
        }
    }

  function updateCallingPoints(section, callingPoints) {
    const reasonBox = section.querySelector('.reason-box');
    const isReasonBoxVisible = window.getComputedStyle(reasonBox).display === 'flex';
    console.log('Reason box visibility:', isReasonBoxVisible);

    const callingPointsPerPage = isReasonBoxVisible ? 9 : 9;
    console.log('Calling points per page:', callingPointsPerPage);

    // Split calling points into pages based on the dynamic page size
    const pages = [];
    for (let i = 0; i < callingPoints.length; i += callingPointsPerPage) {
        pages.push(callingPoints.slice(i, i + callingPointsPerPage));
    }

    console.log('Total pages:', pages.length);

    // Update calling points
    function displayPage(pageIndex) {
        const page = pages[pageIndex] || [];
        console.log('Displaying page index:', pageIndex, 'Content:', page);
        section.querySelector('.calling-points').innerHTML = page.map(loc => `<div>${loc}</div>`).join('');
    }

    // Initial display of the first page
    displayPage(0);

    // Clear previous interval
    if (section.hasAttribute('data-interval')) {
        clearInterval(Number(section.getAttribute('data-interval')));
    }

    // Set a new interval to update calling points every 10 seconds
    section.setAttribute('data-interval', setInterval(() => {
        // Move the first page to the end and display the next page
        pages.push(pages.shift());
        displayPage(0);
    }, 10000));
}


    // Update departures function to handle trainServices array
    async function updateDepartures(crsCode) {
        try {
            console.log('Fetching data from API...');
            const response = await fetch(`https://national-rail-api.davwheat.dev/staffdepartures/${crsCode}?expand=true`);
            const data = await response.json();

            // Log the entire data to the console for debugging
            console.log('API Data:', data);

            // Update station name in the footer
            const stationName = data.locationName || '';
            document.getElementById('station-name').textContent = `Welcome to ${stationName} Railway Station`;

// Update special notices
const specialNotices = data.nrccMessages && data.nrccMessages.length > 0 
    ? data.nrccMessages.map(message => ({
        severity: message.severity || 0, // Default severity to 0 if not present
        content: message.xhtmlMessage
    }))
    : [];

const specialNoticesElement = document.getElementById('special-notices');

if (specialNotices.length === 0) {
    specialNoticesElement.textContent = 'Some train services may be running slightly behind schedule, but no major disruptions have been reported. Please check the screens to the left for real-time updates on your train’s platform and departure time.';
} else {
    // Sort special notices by severity (most severe first)
    specialNotices.sort((a, b) => b.severity - a.severity);

    // Extract sorted messages for display
    const sortedNotices = specialNotices.map(notice => notice.content);

    // Create a temporary element to measure line count
    const tempDiv = document.createElement('div');
    tempDiv.style.visibility = 'hidden'; // Hide the element
    tempDiv.style.position = 'absolute';
    tempDiv.style.width = 'calc(100% - 50px)'; // Use the same width as the special-notices element
    tempDiv.style.fontSize = '47.5px'; // Use the same font size as the special-notices element
    tempDiv.style.lineHeight = '1'; // Set line height to approximate text rendering
    document.body.appendChild(tempDiv);

    // Check line count for combined messages
    let combinedText = sortedNotices.join('<br>');
    tempDiv.innerHTML = combinedText;
    const combinedLines = tempDiv.clientHeight / parseFloat(window.getComputedStyle(tempDiv).lineHeight);

    if (sortedNotices.length === 1 || combinedLines <= 3) {
        // Show all messages if they are 9 lines or fewer, or if there's only one message
        specialNoticesElement.innerHTML = combinedText;
    } else {
        // Otherwise, show only the first message
        specialNoticesElement.innerHTML = sortedNotices[0];
    }

    // Remove the temporary element
    document.body.removeChild(tempDiv);
}

            // Check if data has a property named 'trainServices'
            if (data.trainServices && data.trainServices.length > 0) {
                data.trainServices.forEach((service, index) => {
                    const section = document.querySelector(`.section[data-index="${index}"]`);

                    if (section) {
                        // Platform
                        const platform = service.platform ? `Platform ${service.platform}` : 'Platform N/A';
                        section.querySelector('.platform').textContent = platform;

                        // Time
                        const time = formatTime(service.std);
                        section.querySelector('.time').textContent = time;

                        // Status
                        const statusBox = section.querySelector('.status-box');
                        const std = service.std ? new Date(service.std).getTime() : null;
                        const etd = service.etd ? new Date(service.etd).getTime() : null;
                        const etdFormatted = formatTime(service.etd); // Format ETD time for display

                        const oneMinute = 60 * 1000; // 1 minute in milliseconds

                        if (service.isCancelled) {
                            statusBox.textContent = 'Cancelled';
                            statusBox.style.backgroundColor = '#d4351c'; // Red background
                            statusBox.style.color = 'white'; // White text
                        } else if (etd !== null && std !== null) {
                            if (etd > std) {
                                statusBox.textContent = `Exp ${etdFormatted}`;
                                statusBox.style.backgroundColor = '#db5039'; // Red background
                                statusBox.style.color = 'white'; // White text
                            } else if (Math.abs(etd - std) <= oneMinute) {
                                statusBox.textContent = 'On Time';
                                statusBox.style.backgroundColor = 'white';
                                statusBox.style.color = 'black';
                            } else if (etd < std && std - etd <= 1 * oneMinute) { // Assuming "a few minutes" means up to 5 minutes
                                statusBox.textContent = 'On Time';
                                statusBox.style.backgroundColor = 'white';
                                statusBox.style.color = 'black';
                            } else {
                                statusBox.textContent = 'Arrived'; // Default status for other cases
                                statusBox.style.backgroundColor = 'white'; // Red background
                                statusBox.style.color = 'black'; // White text
                            }
                        } else {
                            statusBox.textContent = 'N/A';
                            statusBox.style.backgroundColor = 'white';
                            statusBox.style.color = 'black';
                        }

                        // Destination
                        const destination = service.destination && service.destination.length > 0 ? service.destination[0].locationName || 'N/A' : 'N/A';
                        section.querySelector('.destination').textContent = destination;

                        // Calling Points
                        const currentSubsequentLocations = service.subsequentLocations
                            .filter(location => !location.isPass) // Only locations where isPass is false
                            .map(loc => {
                                // Remove text within brackets
                                const cleanedName = loc.locationName.replace(/\s*\(.*?\)\s*/g, '');
                                const std = formatTime(loc.std);
                                const eta = formatTime(loc.eta);

                                // Use ETA for the last calling point, otherwise use STD
                                const timeToShow = loc === service.subsequentLocations[service.subsequentLocations.length - 1] ? eta : std;

                                return `${truncateCallingPoint(cleanedName)} (${timeToShow})`;
                            });

                        // Compare current destinations with the previous ones
                        if (previousDestinations[index] !== destination) {
                            previousDestinations[index] = destination;

                            // Update calling points
                            updateCallingPoints(section, currentSubsequentLocations);
                        }

                        // Operator
                        let operator = service.operator || 'N/A';
                        if (operator === 'West Midlands Trains') {
                            operator = 'London Northwestern Railway';
                        }
                        if (operator !== 'TransPennine Express') {
                            operator = truncateText(operator, 17);
                        }
                        section.querySelector('.toc').textContent = operator;

                        // Carriages (formation)
                        let formation = null;

                        // Check if formation and coaches array are available
                        if (service.formation && service.formation.coaches) {
                            // Count the number of coaches in the formation
                            formation = service.formation.coaches.length;
                        }

                        // Fallback to the 'length' field if no valid formation found
                        if (formation === null || formation === undefined) {
                            formation = service.length;
                        }

                        // Determine the display message based on formation
                        let displayText = '';
                        let textColor = 'yellow'; // Default color

                        if (formation === '0' || formation === null || formation === undefined) {
                            displayText = 'No coach length data';
                            textColor = 'black'; // Different color for "No data"
                        } else {
                            displayText = `${formation} carriages`;
                        }

                        // Set carriages text and color
                        section.querySelector('.carriages').style.color = textColor;
                        section.querySelector('.carriages').textContent = displayText;

                        // Handle reasons for delay or cancellation
                        handleReasons(service, section);
                    } else {
                        console.log(`No data available for section ${index + 1}`);
                    }
                });
            } else {
                console.log('No train services available.');
            }
        } catch (error) {
            console.error('Error fetching departures data:', error);
        }
    }

    // Function to start updating both the departures and calling points
    function startUpdating(crsCode) {
        // Initial update
        updateDepartures(crsCode);
        // Set an interval to update every 10 seconds
        setInterval(() => updateDepartures(crsCode), 10000);
    }

    // Call the initialize function and start updating
    window.onload = function() {
        initialize().then(() => {
            const crsCode = "CAR"; // You can change this to any valid CRS code
            startUpdating(crsCode); // Start updating departures and calling points for the CRS code
        });
    };
            // Function to format time into HH:MM:SS
        function formatCurrentTime() {
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const seconds = now.getSeconds().toString().padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }

        // Function to update the current time every second
        function updateCurrentTime() {
            document.getElementById('current-time').textContent = formatCurrentTime();
        }

        // Start updating the time
        setInterval(updateCurrentTime, 1000);
        updateCurrentTime(); // Initialize the time display


</script>




</body>
</html>
